<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>C++ Editor + Terminal (GitHub Pages)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Register a same-origin COOP/COEP Service Worker -->
  <script>
    (function(){
      if ('serviceWorker' in navigator) {
        // Use ONE of these two lines:
        // 1) Shared SW at origin root (covers ALL projects on acaringijr.github.io):
        // navigator.serviceWorker.register('/coi-serviceworker.js');
        // 2) Per-project SW (file lives next to this index.html):
        navigator.serviceWorker.register('./coi-serviceworker.js');
      }
    })();
  </script>

  <!-- Ace Editor -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.36.2/ace.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.36.2/ext-language_tools.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.36.2/mode-c_cpp.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.36.2/theme-monokai.min.js" crossorigin="anonymous"></script>

  <!-- xterm.js -->
  <link rel="stylesheet" href="https://unpkg.com/@xterm/xterm/css/xterm.css" />
  <script type="module">
    import { Terminal } from "https://unpkg.com/@xterm/xterm@5.5.0?module";
    import { FitAddon } from "https://unpkg.com/@xterm/addon-fit@0.10.0?module";
    window.XTerm = { Terminal, FitAddon };
  </script>

  <style>
    :root {
      --bg:#1e1e1e; --panel:#252526; --fg:#ddd; --btn:#2d2d30; --btnb:#444;
      --accent:#0e639c; --danger:#c33;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .grid{display:grid;grid-template-columns:1fr 6px 1fr;height:100vh}
    .left,.right{display:flex;flex-direction:column;background:var(--panel);overflow:hidden}
    .drag{width:6px;cursor:col-resize;background:#0004}
    .toolbar{display:flex;gap:.5rem;padding:.5rem;background:#0006;align-items:center;flex-wrap:wrap}
    button{background:var(--btn);border:1px solid var(--btnb);color:var(--fg);padding:.4rem .7rem;border-radius:6px;cursor:pointer}
    button.primary{background:var(--accent);border-color:#0a4f79}
    button.danger{background:var(--danger);border-color:#a22}
    .editor{flex:1;min-height:0}
    #editor{width:100%;height:100%}
    .termWrap{position:relative;height:60%;min-height:200px}
    #terminal{width:100%;height:100%;padding:.25rem}
    .stdinWrap{display:flex;gap:.5rem;padding:.5rem;background:#0006;align-items:center}
    .stdinWrap textarea{flex:1;resize:vertical;min-height:70px;max-height:40vh;background:#111;color:#ddd;border:1px solid #333;border-radius:6px;padding:.5rem}
    .status{margin-left:auto;opacity:.8;font-size:12px}
    .footer{padding:.4rem .6rem;font-size:12px;opacity:.8}
  </style>
</head>
<body>
  <div class="grid">
    <section class="left">
      <div class="toolbar">
        <button id="compileBtn" class="primary">Compile</button>
        <button id="runBtn">Run (interactive)</button>
        <button id="runBatchBtn">Run with batch stdin</button>
        <button id="downloadBtn">Download .wasm</button>
        <span class="status" id="status">idle</span>
      </div>
      <div class="editor"><div id="editor"></div></div>
    </section>
    <div class="drag" id="drag"></div>
    <section class="right">
      <div class="termWrap"><div id="terminal"></div></div>
      <div class="stdinWrap">
        <label for="stdin">Batch stdin:</label>
        <textarea id="stdin" placeholder="Type lines that will be fed to your program when you click 'Run with batch stdin'&#10;Example:&#10;Alice&#10;42"></textarea>
      </div>
      <div class="footer">
        First compile may take a bit while the Clang toolchain loads (client-side). Afterwards it’s cached.
      </div>
    </section>
  </div>

  <script type="module">
    // --- Editor setup ---
    const editor = ace.edit("editor");
    editor.setTheme("ace/theme/monokai");
    editor.session.setMode("ace/mode/c_cpp");
    editor.setOptions({
      fontSize: 14, tabSize: 2, useSoftTabs: true, showPrintMargin: false,
      enableBasicAutocompletion: true, enableLiveAutocompletion: true,
    });
    const DEFAULT_CPP = `#include <bits/stdc++.h>
using namespace std;
int main(){
  ios::sync_with_stdio(false); cin.tie(nullptr);
  string name; int x;
  if(!(cin >> name)) return 0;
  if(!(cin >> x)) x = 0;
  cout << "Hello " << name << "! x=" << x << "\\n";
  return 0;
}`;
    if (!localStorage.getItem("cppCode")) editor.setValue(DEFAULT_CPP, -1);
    editor.session.on('change', () => localStorage.setItem("cppCode", editor.getValue()));
    const saved = localStorage.getItem("cppCode"); if (saved) editor.setValue(saved, -1);

    // --- Resizable split ---
    const grid = document.querySelector('.grid');
    const drag = document.getElementById('drag');
    drag.addEventListener('pointerdown', e => {
      const startX = e.clientX; const cols = grid.getBoundingClientRect().width;
      const startLeft = grid.children[0].getBoundingClientRect().width;
      function move(ev){
        const dx = ev.clientX - startX;
        const newLeft = Math.min(cols - 100, Math.max(200, startLeft + dx));
        grid.style.gridTemplateColumns = `${newLeft}px 6px ${cols - newLeft - 6}px`;
        termFit.fit();
      }
      const up=()=>{window.removeEventListener('pointermove',move);window.removeEventListener('pointerup',up)};
      window.addEventListener('pointermove',move); window.addEventListener('pointerup',up);
    });

    // --- Terminal ---
    const term = new XTerm.Terminal({ convertEol:true, cursorBlink:true });
    const termFit = new XTerm.FitAddon();
    term.loadAddon(termFit);
    term.open(document.getElementById('terminal'));
    termFit.fit();
    window.addEventListener('resize', () => termFit.fit());
    const log = s => term.writeln((s||'').toString().replace(/\n/g,"\r\n"));

    // --- Wasmer SDK (dynamically import) ---
    let Wasmer, init, Directory;
    let compiledWasmBytes = null;
    const status = document.getElementById('status');
    const setStatus = s => status.textContent = s;

    async function loadSDK(){
      if (Wasmer) return;
      const sdk = await import("https://unpkg.com/@wasmer/sdk@latest/dist/index.mjs");
      Wasmer = sdk.Wasmer;
      init = sdk.init;
      Directory = sdk.Directory;
      await init();
    }

    // Compile C++ to WASI .wasm via clang/clang registry package
    async function compileCppToWasm(){
      setStatus("loading clang...");
      await loadSDK();
      const clangPkg = await Wasmer.fromRegistry("clang/clang"); // downloads if not cached
      setStatus("compiling...");

      const project = new Directory();
      await project.writeFile("main.cpp", editor.getValue());

      const inst = await clangPkg.entrypoint.run({
        args: ["/p/main.cpp", "-O2", "-std=gnu++17", "-o", "/p/main.wasm"],
        mount: { "/p": project },
      });
      const result = await inst.wait();
      if (!result.ok){
        setStatus("compile failed");
        log("\x1b[31mCompile failed\x1b[0m");
        log(result.stderr || "Unknown error");
        return null;
      }
      compiledWasmBytes = await project.readFile("main.wasm");
      setStatus("compiled ✓");
      log("\x1b[32mCompiled OK -> main.wasm\x1b[0m");
      return compiledWasmBytes;
    }

    // Run WASI program with live terminal stdin
    async function runInteractive(){
      if (!compiledWasmBytes) await compileCppToWasm();
      if (!compiledWasmBytes) return;
      setStatus("launching...");
      const prog = await Wasmer.fromFile(compiledWasmBytes);
      const instance = await prog.entrypoint.run();

      const enc = new TextEncoder();
      const stdinWriter = instance.stdin?.getWriter?.();
      term.onData(data => stdinWriter?.write(enc.encode(data)));
      instance.stdout.pipeTo(new WritableStream({ write: chunk => term.write(chunk) }));
      instance.stderr.pipeTo(new WritableStream({ write: chunk => term.write(chunk) }));

      const out = await instance.wait();
      setStatus(out.ok ? "program exited 0" : `exit ${out.code}`);
    }

    // Run with textarea-provided stdin (batch)
    async function runWithBatch(){
      if (!compiledWasmBytes) await compileCppToWasm();
      if (!compiledWasmBytes) return;
      setStatus("running (batch)...");
      const prog = await Wasmer.fromFile(compiledWasmBytes);

      const batch = (document.getElementById('stdin').value || "") + "\n";
      const enc = new TextEncoder();
      const stdinStream = new ReadableStream({
        start(ctrl){ ctrl.enqueue(enc.encode(batch)); ctrl.close(); }
      });

      const instance = await prog.entrypoint.run({ stdin: stdinStream });
      instance.stdout.pipeTo(new WritableStream({ write: chunk => term.write(chunk) }));
      instance.stderr.pipeTo(new WritableStream({ write: chunk => term.write(chunk) }));
      const out = await instance.wait();
      setStatus(out.ok ? "program exited 0" : `exit ${out.code}`);
    }

    // Buttons
    document.getElementById('compileBtn').onclick = async () => {
      term.clear(); log("\x1b[1mCompiling...\x1b[0m");
      await compileCppToWasm();
    };
    document.getElementById('runBtn').onclick = async () => {
      term.clear(); log("\x1b[1mRunning (interactive)...\x1b[0m\n(Type here; stdin is live)\n");
      await runInteractive();
    };
    document.getElementById('runBatchBtn').onclick = async () => {
      term.clear(); log("\x1b[1mRunning with batch stdin...\x1b[0m\n");
      await runWithBatch();
    };
    document.getElementById('downloadBtn').onclick = async () => {
      if (!compiledWasmBytes) { await compileCppToWasm(); if(!compiledWasmBytes) return; }
      const blob = new Blob([compiledWasmBytes], { type: "application/wasm" });
      const url = URL.createObjectURL(blob);
      const a = Object.assign(document.createElement('a'), { href:url, download:"main.wasm" });
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    };
  </script>
</body>
</html>
